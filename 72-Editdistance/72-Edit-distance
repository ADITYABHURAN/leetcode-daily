//recurssive approach 
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    
    var n = word1.length;
    var m = word2.length;

    var number_of_operations = function(index1,index2){
        //base case 
        if(index1>n-1 && index2>m-1){
           return 0;
        }
        if(index1>n-1){
            return m -index2;
        }
        if(index2>m-1){
            return n - index1;
        }
        //recurssive 
        if(word1[index1]===word2[index2]){
            return number_of_operations(index1 +1,index2+1);
        }
        var insert = 1 + number_of_operations(index1,index2+1);
        var deleteOp = 1 + number_of_operations(index1+1,index2);
        var replace = 1+ number_of_operations(index1+1,index2+1);
        return Math.min(insert,deleteOp,replace)
    }
    return number_of_operations(0,0);
};

//exceeds run time 

//approach 2 : memoization

var minDistance = function(word1, word2) {
    
    var n = word1.length;
    var m = word2.length;

    //make a  2d array for memoization
    var memo = Array.from({length:n},()=>Array(m).fill(-1));
    

    var number_of_operations = function(index1,index2){
        //base case 
        if(index1>n-1 && index2>m-1){
           return 0;
        }
        if(index1>n-1){
            return m -index2;
        }
        if(index2>m-1){
            return n - index1;
        }

        //check if already computed
        if(memo[index1][index2]!==-1){
            return memo[index1][index2];
        }

        //recurssive 
        if(word1[index1]===word2[index2]){
            memo[index1][index2] = number_of_operations(index1 +1,index2+1);
        } else {
        var insert = 1 + number_of_operations(index1,index2+1);
        var deleteOp = 1 + number_of_operations(index1+1,index2);
        var replace = 1+ number_of_operations(index1+1,index2+1);
        memo[index1][index2] = Math.min(insert,deleteOp,replace);
        }
       
        return memo[index1][index2];
    }
    return number_of_operations(0,0);
};

//approach 3 : tabulation

// we always have an extra column while doing tabulation 
//time complexity : O(n*m)
//space complexity : O(n*m)
//initial value across first row and first column is 0-1,2...3,..

/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
//give value of n and m 
let n = word1.length;
let m = word2.length;
//2d dp array
let dp = Array.from({length:n+1}, ()=>Array(m+1).fill(0));  

//initialize first rom and column 
for(let i=0;i<=n;i++) {
  dp[i][0]=i;
}
for(let j=0;j<=m;j++) {
  dp[0][j]=j;
}
//condition for equal 
for(let i=1;i<=n;i++) {
    for(let j=1;j<=m;j++){
    if(word1.charAt(i-1)===word2.charAt(j-1)) {
        dp[i][j] = dp[i-1][j-1]
    }else {
        //      condition for delete , replace and insert 
        let replace = 1 + dp[i-1][j-1];
        let deleteOp = 1 + dp[i-1][j];
        let insert = 1 + dp[i][j-1];
        //only take the minimum value 
        dp[i][j] = Math.min(replace,deleteOp,insert);
        }
    }

}

return dp[n][m];
};
